#!/usr/bin/env node
// @ts-nocheck
const { spawn } = require('child_process');
const fs = require('fs');

// Why wrp (watch-and-recover-process)? --- To have my own process manager like pm2 for server usage.
//          Tags: My own implementation of nodemon which refreshes on crash as well.
//      Q. Why not use while loop in bash script to handle CRASH? --- (1) It is very unreliable and we can have orphan child processes and (2) I need a long term maintainable solution so using javascript is ideal.

// USAGE: (I have added alias to .zshrc file --- alias wrp='~/Documents/github_repos/learn-express/learn-node/watch-and-recover-process/wrp')
//  &   1. Commands
//              wrp node app.js --tag=proj1
//              wrp npx ts-node --transpileOnly src/server.ts --tag=qr-prod-backend
//              nohup ~/Documents/wrp npx ts-node --transpileOnly src/server.ts --tag=qr-prod-backend > wrp.log 2>&1 &
//              nohup ~/Documents/wrp nodemon sqlite3-sseMcpServer.js --tag=sqlite3-sseMcpServer > wrp.log 2>&1 &
//                      (Optionaly, we pass `--tag=proj1` so that we can filter easily in process list (htop, top, etc))
//   &  2. View Logs
//         - `tail -f .log -n100` (APP LOGS) (Learn: Vscode shows delayed logs, TESTED) --- To fix for vscode's issue, the only
//          reliable way is to close the log file with `cmd+w` and reopen it via `cmd+shift+t`.
//              Tip: `tail` Use optional -n (alias for `--lines`) -n100 to show last 100 lines instead of default last 10 lines.
//              Tip: Using `.log` file extension helps vscode to show syntax highlights.
//         - `tail -f wrp.log -n100` (wrp logs)
//   &  3. List wrp processes
//              wrp.ls              (alias for `pgrep -fa /wrp`)
//              wrp.ls.withKids     (alias for `pgrep -fa wrp`)
//   !  4. Kill a wrp process by kiling the parent process via `kill PID`

const LOG_FILE = '.log';

// Inspiration: https://chatgpt.com/c/6900c7c1-a108-8321-ae56-981d9bd2916c
// Note: 1. All processes spawned are automatically killed when you press ctrl+c there are no orphan processes. [TESTED]
// Note: 2. To know which processes are running you can use another terminal to run `pgrep -f app.js` (considering you passes `app.js` to wrp.js as argument).
// Note: We do two things - (1) restart proc when there are file changes and (2) restart when proc crashes with non-zero exit code.
let proc = null;
function isProcRunning() { return proc.exitCode === null; };
let isRestartingProcOnFileChange = false;
let isRecoveringProcOnCrash = false;

let logStream;

if (0 /* Use 1=enable and 0=disable debug logs*/) { console.debug = (...arguments) => { console.log("\tðŸ›‘(debug)", ...arguments); }; } else { console.debug = () => { }; }
if (1 /* Use 1=enable and 0=disable info logs*/) { console.info = (...arguments) => { console.log("\tðŸŸ¢(info) ", ...arguments); }; } else { console.info = () => { }; }

// To be able remove this exit listeners on restart logics we must have a reference to this function
function recoverProcOnCrash(exitCode) {
    if (exitCode !== 0) {
        console.info(`âš ï¸ Proc crashed with code ${exitCode}. Restarting in 2s... ðŸš€`, getHumanReadableIndianTime());
        // We delay restart to prevent crash loops and allow the OS to clean up memory, file handles, or ports.
        isRecoveringProcOnCrash = true;
        setTimeout(() => { start(); isRecoveringProcOnCrash = false; }, 2_000);
    } else { console.debug('Proc exited gracefully (exitCode=0). âœ…'); }
}

// Helpful for debugging
console.debug(process.argv.slice(2));

function start() {
    // We pass comment suffix of `# wrp` so that when we search for `wrp` in htop, we get both wrp and its children proc as well.
    // Learn: We can not push logs to a file using `inherit` thus we are usin `pipe` below:
    proc = spawn(process.argv[2], [...process.argv.slice(3), '# wrp'], { stdio: ['ignore', 'pipe', 'pipe'] /* must be 'pipe' to access streams */, env: { ...process.env, FORCE_COLOR: '1' /* Force color is necessary so that we see colored outputs. */ } });
    proc.on('exit', recoverProcOnCrash);
    // Necessary to create new stream each time otherwise previous stream stops working after proc has exited on crash or killed by our restart logic both. [TESTED]
    logStream = fs.createWriteStream(LOG_FILE, { flags: 'a' });
    logStream.on('finish', () => { console.debug('Log stream closed'); });
    // Pipe stdout and stderr to file
    proc.stdout.pipe(logStream);
    proc.stderr.pipe(logStream);
    // We also log to console (optional)
    proc.stdout.pipe(process.stdout);
    proc.stderr.pipe(process.stderr);
    // logStream.write('Hello world to stream.');
}
// Start the proc initially
start();

// Watch files changes
let timeout;
fs.watch('.', { recursive: true }, (_eventType, filename) => {
    if (filename.startsWith('.git/')) { return; } // ignore file saves in .git folder
    if (filename.startsWith('node_modules/')) { return; } // ignore file saves in node_modules folder
    if (filename === LOG_FILE) { return; }
    if (filename === "nohup.out") { return; }
    if (filename === "wrp.log") { return; }
    if (filename.startsWith('.ignored')) { return; }
    // Learn: This ensures only one callback fires for rapid
    //        successive events. This is necessary because when any file is
    //        changed multiple events (2) are fired on macos [TESTED] probably
    //        'change' and 'rename'.
    clearTimeout(timeout);
    timeout = setTimeout(() => {
        // console.log(`File changed: ${filename}`);
        // Proc restart logic
        restartProcOnFileChange(`file change: ${filename}`);
    }, 100); // wait 100ms to avoid duplicate triggers
});

function restartProcOnFileChange(reason) {
    if (isRecoveringProcOnCrash) { return console.debug('âœ…Cancelled restarting proc becoz recovering previous proc is in progres already.'); }
    isRestartingProcOnFileChange = true;
    console.debug("function - restartProcOnFileChange(..): ðŸš€ ~ reason:", reason);
    if (proc) {
        console.info(`ðŸ”„ Restarting proc due to ${reason}...`, getHumanReadableIndianTime());
        if (isProcRunning()) {
            // Does not throw error when process was not running already [TESTED]
            proc?.kill();
            console.debug('proc KILLED ðŸ’¥', proc.pid);
        }
        // Remove earlier 'exit' listener to prevent its own proc start logic
        proc.off('exit', recoverProcOnCrash);
        start();
    } else {
        // For debugging only
        if (!proc) console.debug('proc is null.');
        if (!isProcRunning()) console.debug('proc is *NOT* running.');
    }
    isRestartingProcOnFileChange = false;
}

process.on('SIGTERM', () => {
    console.debug('Got SIGTERM(15), Terminating process gracefully.');
    // Necessary to kill proc on receiving sigterm otherwise it would be left orphaned.
    proc?.kill();
    process.exit(0); // exiting explicit is necessary to terminate this child process unless script finishes naturally
});

function getHumanReadableIndianTime() { return getHumanReadableIndianTimeFromDate(new Date()); }
function getHumanReadableIndianTimeFromDate(date) { return date.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }); }; // Output: 20/2/2025, 9:07:18 pm
