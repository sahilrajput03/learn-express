#!/usr/bin/env node
// @ts-nocheck
const { spawn } = require('child_process');
const fs = require('fs');

// Why wrp? --- To have my own process manager like pm2 for server usage.
// Why not use while loop in bash script to handle CRASH? --- (1) It is very unreliable and we can have orphan child processes and (2) I need a long term maintainable solution so using javascript is ideal.

// USAGE: (I have added alias to .zshrc file --- alias wrp='~/Documents/github_repos/learn-express/learn-node/watch-and-recover-process/wrp')
//  wrp node app.js --tag=proj1
//  wrp ts-node --transpileOnly src/server.ts --tag=proj1
//      Optionaly, we pass `--tag=proj1` so that we can filter easily in process list (htop, top, etc)

// & Please use command `tail -f .log` to view live logs because vscode shows delayed logs.
//      To fix for vscode, the only reliable way is to close the log file with `cmd+w` and reopen it via `cmd+shift+t`.
// Also, Using `.log` file extension helps vscode to show syntax highlights.
const logFile = '.log';

// Inspiration: https://chatgpt.com/c/6900c7c1-a108-8321-ae56-981d9bd2916c
// Note: 1. All processes spawned are automatically killed when you press ctrl+c there are no orphan processes. [TESTED]
// Note: 2. To know which processes are running you can use another terminal to run `pgrep -f app.js` (considering you passes `app.js` to wrp.js as argument).
// Note: We do two things - (1) restart proc when there are file changes and (2) restart when proc crashes with non-zero exit code.
let proc = null;
function isProcRunning() { return proc.exitCode === null; };
let isRestartingProcOnFileChange = false;
let isRecoveringProcOnCrash = false;

let logStream;

if (0 /* Use 1=enable and 0=disable debug logs*/) { console.debug = (...arguments) => { console.log("\t🛑(debug)", ...arguments); }; } else { console.debug = () => { }; }
if (1 /* Use 1=enable and 0=disable warn logs*/) { console.info = (...arguments) => { console.log("\t🟢(info) ", ...arguments); }; } else { console.info = () => { }; }

// To be able remove this exit listeners on restart logics we must have a reference to this function
function recoverProcOnCrash(exitCode) {
    if (exitCode !== 0) {
        console.info(`⚠️ Proc crashed with code ${exitCode}. Restarting in 2s... 🚀`);
        // We delay restart to prevent crash loops and allow the OS to clean up memory, file handles, or ports.
        isRecoveringProcOnCrash = true;
        setTimeout(() => { start(); isRecoveringProcOnCrash = false; }, 2_000);
    } else { console.debug('Proc exited gracefully (exitCode=0). ✅'); }
}

function start() {
    // We pass comment suffix of `# wrp` so that when we search for `wrp` in htop, we get both wrp and its children proc as well.
    // Learn: We can not push logs to a file using `inherit` thus we are usin `pipe` below:
    proc = spawn(process.argv[2], [...process.argv.slice(3), '# wrp'], { stdio: ['ignore', 'pipe', 'pipe'] /* must be 'pipe' to access streams */, env: { ...process.env, FORCE_COLOR: '1' /* Force color is necessary so that we see colored outputs. */ } });
    proc.on('exit', recoverProcOnCrash);
    // Necessary to create new stream each time otherwise previous stream stops working after proc has exited on crash or killed by our restart logic both. [TESTED]
    logStream = fs.createWriteStream(logFile, { flags: 'a' });
    logStream.on('finish', () => { console.debug('Log stream closed'); });
    // Pipe stdout and stderr to file
    proc.stdout.pipe(logStream);
    proc.stderr.pipe(logStream);
    // We also log to console (optional)
    proc.stdout.pipe(process.stdout);
    proc.stderr.pipe(process.stderr);
    // logStream.write('Hello world to stream.');
}
// Start the proc initially
start();

// Watch files changes
let timeout;
fs.watch('.', { recursive: true }, (_eventType, filename) => {
    if (filename.startsWith('.git/')) { return; } // ignore file saves in .git folder
    if (filename.startsWith('node_modules/')) { return; } // ignore file saves in node_modules folder
    if (filename === logFile) { return; }
    if (filename.startsWith('.ignored')) { return; }
    // Learn: This ensures only one callback fires for rapid
    //        successive events. This is necessary because when any file is
    //        changed multiple events (2) are fired on macos [TESTED] probably
    //        'change' and 'rename'.
    clearTimeout(timeout);
    timeout = setTimeout(() => {
        // console.log(`File changed: ${filename}`);
        // Proc restart logic
        restartProcOnFileChange(`file change: ${filename}`);
    }, 100); // wait 100ms to avoid duplicate triggers
});

function restartProcOnFileChange(reason) {
    if (isRecoveringProcOnCrash) { return console.debug('✅Cancelled restarting proc becoz recovering previous proc is in progres already.'); }
    isRestartingProcOnFileChange = true;
    console.debug("function - restartProcOnFileChange(..): 🚀 ~ reason:", reason);
    if (proc) {
        console.info(`🔄 Restarting proc due to ${reason}...`);
        if (isProcRunning()) {
            // Does not throw error when process was not running already [TESTED]
            proc?.kill();
            console.debug('proc KILLED 💥', proc.pid);
        }
        // Remove earlier 'exit' listener to prevent its own proc start logic
        proc.off('exit', recoverProcOnCrash);
        start();
    } else {
        // For debugging only
        if (!proc) console.debug('proc is null.');
        if (!isProcRunning()) console.debug('proc is *NOT* running.');
    }
    isRestartingProcOnFileChange = false;
}

process.on('SIGTERM', () => {
    console.debug('Got SIGTERM(15), Terminating process gracefully.');
    // Necessary to kill proc on receiving sigterm otherwise it would be left orphaned.
    proc?.kill();
    process.exit(0); // exiting explicit is necessary to terminate this child process unless script finishes naturally
});
